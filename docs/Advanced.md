# Defining services with kRPC

This document provides details about how to define service interfaces and rpc methods. Most code snippets used below can be found in the [Sample project](https://github.com/darvld/krpc/tree/main/sample). For a quick-start guide, see [Getting Started](Basic.md).

## Services as interfaces

To define your own service, add the `@Service` annotation to an interface containing method definitions as specified in this document. Note that services *must* be declared as interfaces, using abstract, open or final classes will raise a compile-time error. 

For multiplatform projects, you can place the service definition inside the Common module, which will make it available to all the platform-specific compilers.

Keep in mind that services *are* interfaces: you can use this fact to mock the service in your tests, or to provide different implementations which don't rely on gRPC (or even make network calls at all).

## Request and response types.

All types used in service methods must be serializable (this is not fully checked by the compiler yet, so it should be manually verified to avoid runtime exceptions). Generic types are supported as long as they are serializable, for example, `List<Int>` is supported but `Flow<String>` isn't (since `Flow<T>` is not serializable). Nested generics such as `Map<String, List<Int>>` are also supported under the same premise.

## Unary calls

Methods annotated with `@UnaryCall` may take zero or more arguments and may omit the return type if it isn't needed. Declarations *must* be marked with the `suspend` modifier, otherwise a compile-time error will be raised.

The following example shows possible definitions:

```kotlin
// Single-request, single-response method
@UnaryCall
suspend fun locationForVehicle(vehicle: Vehicle): Location

// Unit return type, the response is ignored
@UnaryCall
suspend fun stopTracking(vehicle: Vehicle)

// No request, generic (serializable) return type.
@UnaryCall
suspend fun listVehicles(): List<Vehicle>

// Multiple arguments, an internal wrapper named `AddVehicleRequest` is generated 
@UnaryCall
suspend fun addVehicle(id: Long, model: String, tags: String): Boolean
```

## Client-streaming

Methods annotated with `@ClientStream` allow the client to asynchronously send a stream of values to the server using a `Flow<T>`. Like in `@UnaryCall` methods, the return type may be omitted.

Client-streaming methods *must* declare a single parameter of type `Flow<T>`, with `T` being a serializable type (generic or otherwise). Multiple or omitted parameters are not supported.

 You can define a client-streaming call like this (note that the `suspend` modifier is mandatory):

```kotlin
@ClientStream
suspend fun streamRoute(route: Flow<Location>): Boolean
```

## Server-streaming

Methods annotated with `@ServerStream` allow to asynchronously send a stream of values from the server, collecting it as a `Flow<T>`.

Server-streaming methods *must* declare a return type of `Flow<T>`, with `T` being a serializable type. The declaration *must* be marked with the `suspend` modifier, coroutine support is provided implicitly through the returned  `Flow`.

Like with `@UnaryCall`, you can declare zero or more parameters. Server-streaming calls are defined as follows:

```kotlin
@ServerStream
fun trackVehicle(vehicle: Vehicle): Flow<Location>
```

## Bidirectional streaming

Methods annotated with `@BidiStream` allow to simultaneously send streams both ways, using  `Flow`.

Bidi-streaming methods (just like server-streaming methods) must *not* be marked with the `suspend` modifier. A single `Flow<T>` argument must be declared and the return type is also required to be a `Flow`:

```kotlin
@BidiStream
fun continuousTracking(vehicles: Flow<Vehicle>): Flow<Location>
```

## Other resources

This is all you need to now about defining kRPC services. You can check out the source code generated by the compiler if you wish to know more about the internal works of the library, or see the [Roadmap](Roadmap.md) for some insight about the future of the project.
